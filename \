#include "parser.h"

Parser::Parser(Scanner const& scanner)
    : _scanner(scanner), _currentToken(NONE), _exprRoot(nullptr) 

{

}
Term* Parser::createTerm()
{
    int token = _scanner.nextToken();
    _currentToken = token;
    if(token == VAR)
    {
        return new Variable(symtable[_scanner.tokenValue()].first);
    }
    else if(token == NUMBER)
    {
        return new Number(_scanner.tokenValue());
    }
    else if(token == ATOM || token == ATOMSC)
    {
        Atom* atom = new Atom(symtable[_scanner.tokenValue()].first);
        if(_scanner.currentChar() == '(' ) 
        {
            return structure();
        }
        else
            return atom;
    }
    else if(token == '[')
    {
        return list();
    }
    return nullptr;
}

Term* Parser::structure() 
{
    Atom structName = Atom(symtable[_scanner.tokenValue()].first);
    int startIndexOfStructArgs = _terms.size();
    _scanner.nextToken();
    createTerms();
    if(_currentToken == ')')

    {
        vector<Term *> args(_terms.begin() + startIndexOfStructArgs, _terms.end());
        _terms.erase(_terms.begin() + startIndexOfStructArgs, _terms.end());
        return new Struct(structName, args);
    }
    else 
    {
        throw std::string("unexpected token");
    }
}

void Parser::matchings()
{
    Term *term;
    Node *node;
    _terms.clear();
    _nodes.clear();
    while((term = createTerm()))
    {
        _terms.push_back(term);

        if(_scanner.currentChar() == '.')
        {
            break;
        }
        else if(_scanner.currentChar() == ',' ||
           _scanner.currentChar() == '=' ||
           _scanner.currentChar() == ';')
        {

            _scanner.nextToken();
        }
    }
}

Node* Parser::expressionTree()
{
    return _exprRoot;
}

Term* Parser::list() 
{
    int startIndexOfListArgs = _terms.size();
    createTerms();
    if(_currentToken == ']')

    {
        vector<Term *> args(_terms.begin() + startIndexOfListArgs, _terms.end());
        _terms.erase(_terms.begin() + startIndexOfListArgs, _terms.end());
        return new List(args);
    } else 
    {
        throw std::string("unexpected token");
    }
}

std::vector<Term *>& Parser::getTerms() 
{
    return _terms;
}


void Parser::createTerms()
{
    Term* term = createTerm();
    if(term != nullptr)
    {
        _terms.push_back(term);
        while((_currentToken = _scanner.nextToken()) == ',')  
            _terms.push_back(createTerm());
    }
}

